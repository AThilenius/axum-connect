use std::path::Path;

use convert_case::{Case, Casing};
use protobuf::reflect::FileDescriptor;
use protobuf_codegen::{
    gen::scope::{RootScope, WithScope},
    Codegen,
};
use protobuf_parse::ProtobufAbsPath;

// TODO There is certainly a much easier way to do this, but I can't make sense of rust-protobuf.
pub fn axum_connect_codegen(
    include: impl AsRef<Path>,
    inputs: impl IntoIterator<Item = impl AsRef<Path>>,
) -> anyhow::Result<()> {
    let results = Codegen::new()
        .pure()
        .cargo_out_dir("connect_proto_gen")
        .inputs(inputs)
        .include(include)
        .run()?;

    let file_descriptors =
        FileDescriptor::new_dynamic_fds(results.parsed.file_descriptors.clone(), &[])?;

    let root_scope = RootScope {
        file_descriptors: &file_descriptors.as_slice(),
    };

    for path in results.parsed.relative_paths {
        // Find the relative file descriptor
        let file_descriptor = results
            .parsed
            .file_descriptors
            .iter()
            .find(|&fd| fd.name.clone().unwrap_or_default().ends_with(path.to_str()))
            .expect(&format!(
                "find a file descriptor matching the relative path {}",
                path.to_str()
            ));

        // TODO: This seems fragile.
        let path = path.to_path().with_extension("rs");
        let cargo_out_dir = std::env::var("OUT_DIR")?;
        let out_dir = Path::new(&cargo_out_dir).join("connect_proto_gen");
        let proto_rs_file_name = path.file_name().unwrap().to_str().unwrap();
        let proto_rs_full_path = out_dir.join(&proto_rs_file_name);

        // Replace all instances of "::protobuf::" with "::axum_connect::protobuf::" in the original
        // generated file.
        let rust = std::fs::read_to_string(&proto_rs_full_path)?;
        let rust = rust.replace("::protobuf::", "::axum_connect::protobuf::");
        // std::fs::write(&proto_rs_full_path, rust)?;

        // Build up the service implementation file source.
        let mut c = String::new();

        c.push_str(FILE_PREAMBLE_TEMPLATE);

        for service in &file_descriptor.service {
            // Build up methods first
            let mut m = String::new();

            for method in &service.method {
                let input_type = root_scope
                    .find_message(&ProtobufAbsPath {
                        path: method.input_type().to_string(),
                    })
                    .rust_name_with_file()
                    .to_path()
                    .to_string();

                let output_type = root_scope
                    .find_message(&ProtobufAbsPath {
                        path: method.output_type().to_string(),
                    })
                    .rust_name_with_file()
                    .to_path()
                    .to_string();

                m.push_str(
                    &METHOD_TEMPLATE
                        .replace("@@METHOD_NAME@@", &method.name().to_case(Case::Snake))
                        .replace("@@INPUT_TYPE@@", &input_type)
                        .replace("@@OUTPUT_TYPE@@", &output_type)
                        .replace(
                            "@@ROUTE@@",
                            &format!(
                                "/{}.{}/{}",
                                file_descriptor.package(),
                                service.name(),
                                method.name()
                            ),
                        ),
                );
            }

            c.push_str(
                &SERVICE_TEMPLATE
                    .replace("@@SERVICE_NAME@@", service.name())
                    .replace("@@SERVICE_METHODS@@", &m),
            );
        }

        let mut final_file = String::new();
        final_file.push_str(&rust);
        final_file.push_str(&c);

        std::fs::write(&proto_rs_full_path, &final_file)?;
    }

    Ok(())
}

const FILE_PREAMBLE_TEMPLATE: &str = "// Generated by axum-connect-build
use axum::{
    body::HttpBody, extract::State, http::Request, response::IntoResponse, routing::post, BoxError,
    Router,
};

use axum_connect::{HandlerFuture, RpcRouter};
";

const SERVICE_TEMPLATE: &str = "
pub struct @@SERVICE_NAME@@;

impl @@SERVICE_NAME@@ {
@@SERVICE_METHODS@@
}";

const METHOD_TEMPLATE: &str = "
    pub fn @@METHOD_NAME@@<T, H, S, B>(handler: H) -> impl FnOnce(Router<S, B>) -> RpcRouter<S, B>
    where
        H: HandlerFuture<super::@@INPUT_TYPE@@, super::@@OUTPUT_TYPE@@, T, S, B>,
        T: 'static,
        S: Clone + Send + Sync + 'static,
        B: HttpBody + Send + 'static,
        B::Data: Send,
        B::Error: Into<BoxError>,
    {
        move |router: Router<S, B>| {
            router.route(
                \"@@ROUTE@@\",
                post(|State(state): State<S>, request: Request<B>| async move {
                    let res = handler.call(request, state).await;
                    ::axum_connect::protobuf_json_mapping::print_to_string(&res)
                        .unwrap()
                        .into_response()
                }),
            )
        }
    }
";
